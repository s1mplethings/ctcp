diff --git a/web/graph_force/README.md b/web/graph_force/README.md
new file mode 100644
index 0000000..0e12b9a
--- /dev/null
+++ b/web/graph_force/README.md
@@ -0,0 +1,72 @@
+# Graph Force (Canvas / 暗色蛛网图)
+
+目标：做成类似 Obsidian 的暗色蛛网关系网（灰点 + 灰线 + 文本标签），支持：
+- Hover：节点/关联边高亮
+- Drag：拖拽节点固定位置
+- Pan/Zoom：拖拽空白平移，滚轮缩放
+- Click：选中节点，并优先调用 Qt WebChannel 的桥接对象 GraphBridge（如果存在）
+- 顶部 HUD：显示 selected / 搜索定位
+
+## 入口
+- web/graph_force/index.html
+
+## Qt WebChannel（可选）
+如果 Qt 侧注册了 QWebChannel 对象 `GraphBridge`，本页面会自动连接并调用：
+- GraphBridge.getGraphJson() -> 返回 JSON 字符串（nodes/links）
+- GraphBridge.openNode(nodeJson) -> 点击节点时回调（传 node 的 JSON 字符串）
+（如果没有桥接，会自动加载 sample_graph.json）
+
+## Graph JSON 格式
+{
+  "nodes": [{"id":"welcome","label":"Welcome","path":"..."}],
+  "links": [{"source":"welcome","target":"create_link"}]
+}
+
diff --git a/web/graph_force/index.html b/web/graph_force/index.html
new file mode 100644
index 0000000..e7a8fe9
--- /dev/null
+++ b/web/graph_force/index.html
@@ -0,0 +1,30 @@
+<!doctype html>
+<html lang="zh-CN">
+<head>
+  <meta charset="utf-8" />
+  <meta name="viewport" content="width=device-width, initial-scale=1" />
+  <title>Graph Force</title>
+  <link rel="stylesheet" href="./graph.css" />
+</head>
+<body>
+  <div id="hud">
+    <div class="left">
+      <div class="title">Graph</div>
+      <div id="status" class="status">loading…</div>
+    </div>
+    <div class="right">
+      <input id="search" placeholder="search node…" />
+      <div id="sel" class="sel">selected: (none)</div>
+    </div>
+  </div>
+
+  <canvas id="c"></canvas>
+
+  <!-- Qt WebEngine 里可用 -->
+  <script src="qrc:///qtwebchannel/qwebchannel.js"></script>
+
+  <script src="./force_sim.js"></script>
+  <script src="./graph.js"></script>
+</body>
+</html>
diff --git a/web/graph_force/graph.css b/web/graph_force/graph.css
new file mode 100644
index 0000000..0c6d55c
--- /dev/null
+++ b/web/graph_force/graph.css
@@ -0,0 +1,67 @@
+html, body {
+  margin: 0;
+  width: 100%;
+  height: 100%;
+  background: #111;
+  overflow: hidden;
+  font-family: system-ui, -apple-system, Segoe UI, Roboto, "PingFang SC", "Microsoft YaHei", sans-serif;
+}
+
+#c {
+  width: 100vw;
+  height: 100vh;
+  display: block;
+}
+
+#hud {
+  position: fixed;
+  top: 10px;
+  left: 10px;
+  right: 10px;
+  display: flex;
+  justify-content: space-between;
+  pointer-events: none;
+  z-index: 10;
+}
+
+#hud .left, #hud .right {
+  background: rgba(20, 20, 20, 0.65);
+  border: 1px solid rgba(255,255,255,0.10);
+  border-radius: 10px;
+  padding: 10px 12px;
+  box-shadow: 0 10px 30px rgba(0,0,0,0.25);
+  pointer-events: auto;
+}
+
+.title {
+  color: #eee;
+  font-weight: 700;
+  letter-spacing: 0.3px;
+  margin-bottom: 6px;
+}
+
+.status {
+  color: rgba(255,255,255,0.75);
+  font-size: 12px;
+}
+
+#search {
+  width: 220px;
+  padding: 8px 10px;
+  border-radius: 8px;
+  border: 1px solid rgba(255,255,255,0.12);
+  background: rgba(0,0,0,0.25);
+  color: #eee;
+  outline: none;
+}
+
+.sel {
+  margin-top: 8px;
+  color: rgba(255,255,255,0.85);
+  font-size: 12px;
+}
diff --git a/web/graph_force/sample_graph.json b/web/graph_force/sample_graph.json
new file mode 100644
index 0000000..33cb31e
--- /dev/null
+++ b/web/graph_force/sample_graph.json
@@ -0,0 +1,16 @@
+{
+  "nodes": [
+    { "id": "welcome", "label": "Welcome" },
+    { "id": "create_link", "label": "create a link" },
+    { "id": "main_character", "label": "main character" },
+    { "id": "course", "label": "选课推荐系统" }
+  ],
+  "links": [
+    { "source": "welcome", "target": "create_link" }
+  ]
+}
diff --git a/web/graph_force/force_sim.js b/web/graph_force/force_sim.js
new file mode 100644
index 0000000..a3a4d35
--- /dev/null
+++ b/web/graph_force/force_sim.js
@@ -0,0 +1,198 @@
+// force_sim.js
+// A tiny force-directed simulation (charge + link + center + collide) for Canvas graphs.
+// No external deps. Designed to be "D3-force-like" enough for this project.
+
+(() => {
+  function clamp(v, a, b) { return Math.max(a, Math.min(b, v)); }
+
+  class ForceSim {
+    constructor(nodes, links) {
+      this.nodes = nodes || [];
+      this.links = links || [];
+
+      // params
+      this.chargeStrength = -420;
+      this.linkDistance = 120;
+      this.linkStrength = 0.18;
+      this.centerStrength = 0.0006;
+      this.collideRadius = (n) => (n.r || 6) + 10;
+      this.alpha = 1.0;
+      this.alphaMin = 0.02;
+      this.alphaDecay = 0.02;
+      this.velocityDecay = 0.92;
+
+      this._tick = null;
+      this._running = false;
+      this._raf = 0;
+      this._last = performance.now();
+    }
+
+    onTick(fn) {
+      this._tick = fn;
+      return this;
+    }
+
+    restart() {
+      this.alpha = 1.0;
+      if (!this._running) this.start();
+      return this;
+    }
+
+    start() {
+      if (this._running) return;
+      this._running = true;
+      this._last = performance.now();
+      const loop = () => {
+        if (!this._running) return;
+        this.step();
+        this._raf = requestAnimationFrame(loop);
+      };
+      this._raf = requestAnimationFrame(loop);
+    }
+
+    stop() {
+      this._running = false;
+      if (this._raf) cancelAnimationFrame(this._raf);
+      this._raf = 0;
+    }
+
+    step() {
+      const now = performance.now();
+      const dt = clamp((now - this._last) / 1000, 0.001, 0.03);
+      this._last = now;
+
+      if (this.alpha < this.alphaMin) {
+        if (this._tick) this._tick();
+        return;
+      }
+
+      const a = this.alpha;
+      const nodes = this.nodes;
+      const links = this.links;
+
+      for (const n of nodes) {
+        n.vx = (n.vx || 0) * this.velocityDecay;
+        n.vy = (n.vy || 0) * this.velocityDecay;
+      }
+
+      const kRepel = -this.chargeStrength;
+      for (let i = 0; i < nodes.length; i++) {
+        for (let j = i + 1; j < nodes.length; j++) {
+          const p = nodes[i], q = nodes[j];
+          const dx = p.x - q.x;
+          const dy = p.y - q.y;
+          const d2 = dx * dx + dy * dy + 0.01;
+          const inv = 1 / Math.sqrt(d2);
+          const f = (kRepel / d2) * a;
+          const fx = dx * inv * f;
+          const fy = dy * inv * f;
+          p.vx += fx * dt; p.vy += fy * dt;
+          q.vx -= fx * dt; q.vy -= fy * dt;
+        }
+      }
+
+      const L = this.linkDistance;
+      const kLink = this.linkStrength;
+      for (const e of links) {
+        const s = e.source, t = e.target;
+        const dx = t.x - s.x;
+        const dy = t.y - s.y;
+        const d = Math.sqrt(dx * dx + dy * dy) + 0.001;
+        const diff = d - L;
+        const f = diff * kLink * a;
+        const fx = (dx / d) * f;
+        const fy = (dy / d) * f;
+        s.vx += fx; s.vy += fy;
+        t.vx -= fx; t.vy -= fy;
+      }
+
+      for (let i = 0; i < nodes.length; i++) {
+        for (let j = i + 1; j < nodes.length; j++) {
+          const p = nodes[i], q = nodes[j];
+          const rp = this.collideRadius(p);
+          const rq = this.collideRadius(q);
+          const minD = rp + rq;
+          const dx = q.x - p.x;
+          const dy = q.y - p.y;
+          const d2 = dx * dx + dy * dy + 0.01;
+          const d = Math.sqrt(d2);
+          if (d >= minD) continue;
+          const overlap = (minD - d) / d;
+          const ox = dx * overlap * 0.5 * a;
+          const oy = dy * overlap * 0.5 * a;
+          if (!p._fixed) { p.x -= ox; p.y -= oy; }
+          if (!q._fixed) { q.x += ox; q.y += oy; }
+        }
+      }
+
+      const kC = this.centerStrength * a;
+      for (const n of nodes) {
+        n.vx += (-n.x) * kC;
+        n.vy += (-n.y) * kC;
+      }
+
+      for (const n of nodes) {
+        if (n._fixed) continue;
+        n.x += (n.vx || 0);
+        n.y += (n.vy || 0);
+      }
+
+      this.alpha = this.alpha * (1 - this.alphaDecay);
+      if (this._tick) this._tick();
+    }
+  }
+
+  window.ForceSim = ForceSim;
+})();
diff --git a/web/graph_force/graph.js b/web/graph_force/graph.js
new file mode 100644
index 0000000..d2fe8e3
--- /dev/null
+++ b/web/graph_force/graph.js
@@ -0,0 +1,353 @@
+(function () {
+  const canvas = document.getElementById("c");
+  const ctx = canvas.getContext("2d", { alpha: false });
+
+  const statusEl = document.getElementById("status");
+  const selEl = document.getElementById("sel");
+  const searchEl = document.getElementById("search");
+
+  let scale = 1.0;
+  let offsetX = 0;
+  let offsetY = 0;
+
+  let isDown = false;
+  let downX = 0, downY = 0;
+  let draggingNode = null;
+
+  let nodes = [];
+  let links = [];
+
+  let hovered = null;
+  let selected = null;
+
+  let bridge = null;
+  let sim = null;
+
+  function resize() {
+    const dpr = Math.max(1, window.devicePixelRatio || 1);
+    const w = Math.floor(window.innerWidth * dpr);
+    const h = Math.floor(window.innerHeight * dpr);
+    canvas.width = w;
+    canvas.height = h;
+    canvas.style.width = window.innerWidth + "px";
+    canvas.style.height = window.innerHeight + "px";
+    ctx.setTransform(1, 0, 0, 1, 0, 0);
+    ctx.scale(dpr, dpr);
+    render();
+  }
+  window.addEventListener("resize", resize);
+
+  function worldToScreen(x, y) {
+    return { x: x * scale + offsetX, y: y * scale + offsetY };
+  }
+  function screenToWorld(x, y) {
+    return { x: (x - offsetX) / scale, y: (y - offsetY) / scale };
+  }
+
+  function pickNode(mx, my) {
+    const p = screenToWorld(mx, my);
+    let best = null;
+    let bestD2 = Infinity;
+    for (const n of nodes) {
+      const r = (n.r || 6) + 6;
+      const dx = p.x - n.x;
+      const dy = p.y - n.y;
+      const d2 = dx * dx + dy * dy;
+      if (d2 < r * r && d2 < bestD2) {
+        best = n;
+        bestD2 = d2;
+      }
+    }
+    return best;
+  }
+
+  function render() {
+    const w = window.innerWidth;
+    const h = window.innerHeight;
+
+    ctx.fillStyle = "#111";
+    ctx.fillRect(0, 0, w, h);
+
+    ctx.lineWidth = 1;
+    for (const e of links) {
+      const s = e.source;
+      const t = e.target;
+      const a = (hovered && (s === hovered || t === hovered)) ? 0.9 : 0.25;
+      ctx.strokeStyle = `rgba(200,200,200,${a})`;
+      const p1 = worldToScreen(s.x, s.y);
+      const p2 = worldToScreen(t.x, t.y);
+      ctx.beginPath();
+      ctx.moveTo(p1.x, p1.y);
+      ctx.lineTo(p2.x, p2.y);
+      ctx.stroke();
+    }
+
+    for (const n of nodes) {
+      const p = worldToScreen(n.x, n.y);
+      const baseR = n.r || 6;
+      const r = (n === hovered || n === selected) ? baseR + 2 : baseR;
+      const alpha = (n === hovered || n === selected) ? 0.95 : 0.75;
+
+      ctx.fillStyle = `rgba(220,220,220,${alpha})`;
+      ctx.beginPath();
+      ctx.arc(p.x, p.y, r, 0, Math.PI * 2);
+      ctx.fill();
+
+      ctx.font = "14px system-ui, -apple-system, Segoe UI, Roboto, sans-serif";
+      ctx.fillStyle = "rgba(245,245,245,0.92)";
+      ctx.textBaseline = "middle";
+      ctx.fillText(n.label ?? n.id, p.x + r + 8, p.y);
+    }
+  }
+
+  async function loadGraphData() {
+    if (bridge && typeof bridge.getGraphJson === "function") {
+      try {
+        const txt = await bridge.getGraphJson();
+        const g = JSON.parse(txt);
+        statusEl.textContent = "Qt graph loaded";
+        return g;
+      } catch (e) {}
+    }
+    try {
+      const r = await fetch("./sample_graph.json", { cache: "no-store" });
+      statusEl.textContent = "sample_graph.json loaded";
+      return await r.json();
+    } catch (e) {}
+    statusEl.textContent = "inline fallback graph";
+    return {
+      nodes: [
+        { id: "welcome", label: "Welcome" },
+        { id: "create_link", label: "create a link" },
+        { id: "main_character", label: "main character" },
+        { id: "course", label: "选课推荐系统" }
+      ],
+      links: [{ source: "welcome", target: "create_link" }]
+    };
+  }
+
+  function normalizeGraph(g) {
+    const map = new Map();
+    nodes = (g.nodes || []).map((n, i) => {
+      const id = n.id ?? String(i);
+      const obj = {
+        id,
+        label: n.label ?? id,
+        path: n.path ?? "",
+        r: n.r ?? 6,
+        x: (n.x ?? (Math.random() - 0.5) * 400),
+        y: (n.y ?? (Math.random() - 0.5) * 260),
+        vx: 0,
+        vy: 0,
+        _fixed: false
+      };
+      map.set(id, obj);
+      return obj;
+    });
+
+    links = (g.links || []).map(e => {
+      const s = (typeof e.source === "string") ? map.get(e.source) : e.source;
+      const t = (typeof e.target === "string") ? map.get(e.target) : e.target;
+      return { source: s, target: t };
+    }).filter(e => e.source && e.target);
+
+    offsetX = window.innerWidth * 0.5;
+    offsetY = window.innerHeight * 0.5;
+    scale = 1.0;
+  }
+
+  function connectQtBridge() {
+    try {
+      if (typeof QWebChannel !== "undefined" && window.qt && qt.webChannelTransport) {
+        new QWebChannel(qt.webChannelTransport, (channel) => {
+          bridge = channel.objects.GraphBridge || channel.objects.bridge || null;
+          statusEl.textContent = bridge ? "Qt bridge connected" : "Qt channel ok, bridge missing";
+          boot();
+        });
+        return true;
+      }
+    } catch (_) {}
+    return false;
+  }
+
+  function startSim() {
+    if (!window.ForceSim) {
+      statusEl.textContent = "ForceSim missing";
+      return;
+    }
+    sim = new window.ForceSim(nodes, links).onTick(render);
+    sim.restart();
+    statusEl.textContent = `${statusEl.textContent} | nodes=${nodes.length} links=${links.length}`;
+  }
+
+  canvas.addEventListener("mousemove", (ev) => {
+    const mx = ev.clientX, my = ev.clientY;
+    if (isDown) {
+      const dx = mx - downX;
+      const dy = my - downY;
+      if (draggingNode) {
+        const p = screenToWorld(mx, my);
+        draggingNode.x = p.x;
+        draggingNode.y = p.y;
+        draggingNode._fixed = true;
+        if (sim) sim.restart();
+      } else {
+        offsetX += dx;
+        offsetY += dy;
+      }
+      downX = mx;
+      downY = my;
+      render();
+      return;
+    }
+    const hit = pickNode(mx, my);
+    if (hit !== hovered) { hovered = hit; render(); }
+  });
+
+  canvas.addEventListener("mousedown", (ev) => {
+    isDown = true;
+    downX = ev.clientX;
+    downY = ev.clientY;
+    draggingNode = pickNode(downX, downY);
+  });
+  window.addEventListener("mouseup", () => { isDown = false; draggingNode = null; });
+
+  canvas.addEventListener("wheel", (ev) => {
+    ev.preventDefault();
+    const mx = ev.clientX, my = ev.clientY;
+    const before = screenToWorld(mx, my);
+    const z = Math.exp(-ev.deltaY * 0.001);
+    scale = Math.min(3.5, Math.max(0.25, scale * z));
+    const after = worldToScreen(before.x, before.y);
+    offsetX += (mx - after.x);
+    offsetY += (my - after.y);
+    render();
+  }, { passive: false });
+
+  canvas.addEventListener("click", async (ev) => {
+    const hit = pickNode(ev.clientX, ev.clientY);
+    if (!hit) return;
+    selected = hit;
+    selEl.textContent = `selected: ${hit.label}${hit.path ? "  |  " + hit.path : ""}`;
+    render();
+    if (bridge && typeof bridge.openNode === "function") {
+      try { await bridge.openNode(JSON.stringify(hit)); } catch (_) {}
+    } else if (bridge && typeof bridge.openPath === "function") {
+      try { await bridge.openPath(hit.path || hit.id); } catch (_) {}
+    }
+  });
+
+  searchEl.addEventListener("input", () => {
+    const q = (searchEl.value || "").trim().toLowerCase();
+    if (!q) { hovered = null; render(); return; }
+    hovered = nodes.find(n => (n.label || n.id).toLowerCase().includes(q)) || null;
+    render();
+  });
+
+  async function boot() {
+    const g = await loadGraphData();
+    normalizeGraph(g);
+    resize();
+    startSim();
+  }
+
+  if (!connectQtBridge()) boot();
+})();
