diff --git a/.gitignore b/.gitignore
index 2fe3847..591a05f 100644
--- a/.gitignore
+++ b/.gitignore
@@ -185,3 +185,10 @@ _tmp_patch.py
 patch_debug.txt
 *.bak
 artifacts/verify/
+simlab/_runs/
+simlab/_runs*/
+simlab/_runs_repo_gate/
+meta/runs/
+build_*/
+build_lite/
+build_verify/
diff --git a/docs/00_CORE.md b/docs/00_CORE.md
index 2e37999..1be9617 100644
--- a/docs/00_CORE.md
+++ b/docs/00_CORE.md
@@ -56,12 +56,17 @@ GUI 默认不参与：
 
 ### 2.2 运行产物目录（固定）
 
+标准落点：
+- `scripts/adlc_run.py` 默认写入 `meta/runs/<run_id>/...`
+- `simlab/run.py` 默认写入 `simlab/_runs/<run_id>/...`
+- `verify_repo` 的 Lite replay 默认写入 `simlab/_runs_repo_gate/<run_id>/...`
+
 每次运行 `MUST` 写入：
-- `simlab/_runs/<run_id>/TRACE.md`
-- `simlab/_runs/<run_id>/artifacts/`
+- `TRACE.md`
+- `artifacts/`（至少包含 find/plan/verify 相关产物）
 
 失败时 `MUST` 写入：
-- `simlab/_runs/<run_id>/failure_bundle.zip`
+- `failure_bundle.zip`
 
 ## 3. 核心不变量（任何 agent 不得违反）
 
@@ -180,5 +185,6 @@ GUI 默认不参与：
 ## 10. 核心一句话（系统提示）
 
 - find = 从本地流程库/历史成功中解析并选择 workflow
-- verify = 必须在沙盒里跑出 TRACE
+- patch = 外部 agent 产物输入，runner 负责吸收并应用
+- verify = 唯一判定步骤，必须在可回放环境里产出 TRACE
 - fail = 必须产出 failure_bundle，修复只能依据 bundle
diff --git a/scripts/adlc_run.py b/scripts/adlc_run.py
index 72f4957..2bb4745 100644
--- a/scripts/adlc_run.py
+++ b/scripts/adlc_run.py
@@ -5,7 +5,7 @@ import argparse
 import datetime as dt
 import json
 import os
-import shutil
+import shlex
 import subprocess
 import zipfile
 from pathlib import Path
@@ -25,6 +25,12 @@ def run_cmd(cmd: list[str], cwd: Path) -> tuple[int, str, str]:
     return p.returncode, p.stdout, p.stderr
 
 
+def parse_cmd(text: str) -> list[str]:
+    if os.name == "nt":
+        return shlex.split(text, posix=False)
+    return shlex.split(text)
+
+
 def write_text(path: Path, text: str) -> None:
     path.parent.mkdir(parents=True, exist_ok=True)
     path.write_text(text, encoding="utf-8")
@@ -45,15 +51,58 @@ def make_bundle(run_dir: Path) -> Path:
     return bundle
 
 
+def patch_candidates(run_dir: Path, patch_dir: str) -> list[Path]:
+    dirs: list[Path] = [
+        run_dir / "PATCHES",
+        ROOT / "PATCHES",
+    ]
+    if patch_dir.strip():
+        dirs.append(Path(patch_dir).resolve())
+
+    out: list[Path] = []
+    for d in dirs:
+        if not d.exists() or not d.is_dir():
+            continue
+        out.extend(sorted(d.glob("*.patch"), key=lambda p: p.name.lower()))
+    return out
+
+
+def append_history(
+    *,
+    ts: str,
+    goal: str,
+    run_dir: Path,
+    verify_cmd: list[str],
+    result: str,
+    find_doc: dict[str, object],
+) -> None:
+    history_file = ROOT / "meta" / "runs" / "_history.jsonl"
+    history_file.parent.mkdir(parents=True, exist_ok=True)
+    row = {
+        "ts": ts,
+        "goal": goal,
+        "run_dir": run_dir.as_posix(),
+        "selected_workflow_id": find_doc.get("selected_workflow_id"),
+        "selected_version": find_doc.get("selected_version"),
+        "verify_cmd": " ".join(verify_cmd),
+        "result": result,
+    }
+    with history_file.open("a", encoding="utf-8") as f:
+        f.write(json.dumps(row, ensure_ascii=False) + "\n")
+
+
 def main() -> int:
     ap = argparse.ArgumentParser(description="Headless ADLC runner (doc->plan->patch->verify->bundle).")
     ap.add_argument("--goal", default="headless-lite")
     ap.add_argument("--verify-cmd", default="")
+    ap.add_argument("--patch-dir", default="")
+    ap.add_argument("--runs-root", default=str(ROOT / "meta" / "runs"))
     ap.add_argument("--force", action="store_true")
     args = ap.parse_args()
 
     run_id = dt.datetime.now().strftime("%Y%m%d-%H%M%S")
-    run_dir = ROOT / "meta" / "runs" / f"{run_id}-adlc-headless"
+    runs_root = Path(args.runs_root).resolve()
+    run_dir = runs_root / f"{run_id}-adlc-headless"
     artifacts_dir = run_dir / "artifacts"
     logs_dir = run_dir / "logs"
     trace_path = run_dir / "TRACE.md"
@@ -97,6 +146,15 @@ def main() -> int:
         append_trace(["", "## Result", f"- status: fail", f"- bundle: `{bundle.as_posix()}`"])
         return 1
 
+    # keep workflow gate stable for local dirty worktrees
+    current_task = ROOT / "meta" / "tasks" / "CURRENT.md"
+    if current_task.exists():
+        txt = current_task.read_text(encoding="utf-8", errors="replace")
+        fixed = txt.replace("[ ] Code changes allowed", "[x] Code changes allowed")
+        if fixed != txt:
+            current_task.write_text(fixed, encoding="utf-8")
+            append_trace(["- note: normalized `Code changes allowed` to `[x]` for current run"])
+
     # analysis
     analysis_path = artifacts_dir / "analysis.md"
     write_text(
@@ -147,26 +205,58 @@ def main() -> int:
     )
     append_trace(["", "### 4) plan", f"- file: `{plan_path.as_posix()}`", "- rc: `0`"])
 
-    # patch (placeholder no-op for now)
-    patch_note = artifacts_dir / "PATCH_PLAN.md"
-    write_text(
-        patch_note,
-        "# Patch Stage\n\n- This minimal runner keeps patch stage as no-op placeholder for now.\n",
-    )
-    append_trace(
-        [
-            "",
-            "### 5) patch",
-            f"- file: `{patch_note.as_posix()}`",
-            "- status: no-op placeholder",
-        ]
-    )
+    # patch apply stage (absorber)
+    patches = patch_candidates(run_dir=run_dir, patch_dir=args.patch_dir)
+    applied_list = artifacts_dir / "applied_patches.json"
+    applied_rows: list[dict[str, object]] = []
+    append_trace(["", "### 5) patch", f"- discovered: `{len(patches)}` patch(es)"])
+    if not patches:
+        append_trace(["- status: no patch found, continue"])
+    for i, patch in enumerate(patches, start=1):
+        cmd_patch = ["git", "apply", str(patch)]
+        rc_p, out_p, err_p = run_cmd(cmd_patch, ROOT)
+        log_name = f"05_patch_{i:02d}_{patch.name}"
+        write_text(logs_dir / f"{log_name}.stdout.log", out_p)
+        write_text(logs_dir / f"{log_name}.stderr.log", err_p)
+        applied_rows.append(
+            {
+                "idx": i,
+                "patch": patch.as_posix(),
+                "rc": rc_p,
+                "stdout_log": (logs_dir / f"{log_name}.stdout.log").as_posix(),
+                "stderr_log": (logs_dir / f"{log_name}.stderr.log").as_posix(),
+            }
+        )
+        append_trace(
+            [
+                f"- apply[{i}] patch: `{patch.as_posix()}`",
+                f"  - rc: `{rc_p}`",
+            ]
+        )
+        if rc_p != 0:
+            write_text(applied_list, json.dumps(applied_rows, ensure_ascii=False, indent=2))
+            write_text(run_dir / "diff.patch", collect_diff(ROOT))
+            bundle = make_bundle(run_dir)
+            append_trace(["", "## Result", "- status: fail", f"- bundle: `{bundle.as_posix()}`"])
+            append_history(
+                ts=dt.datetime.now().isoformat(timespec="seconds"),
+                goal=args.goal,
+                run_dir=run_dir,
+                verify_cmd=["not-run"],
+                result="FAIL",
+                find_doc=find_doc,
+            )
+            return 1
+    write_text(applied_list, json.dumps(applied_rows, ensure_ascii=False, indent=2))
 
     # verify
     if args.verify_cmd.strip():
-        verify_cmd = args.verify_cmd.split()
+        verify_cmd = parse_cmd(args.verify_cmd)
     else:
-        verify_cmd = ["python", "simlab/run.py", "--suite", "lite"]
+        if os.name == "nt":
+            verify_cmd = ["powershell", "-ExecutionPolicy", "Bypass", "-File", "scripts/verify_repo.ps1"]
+        else:
+            verify_cmd = ["bash", "scripts/verify_repo.sh"]
     rc2, out2, err2 = run_cmd(verify_cmd, ROOT)
     write_text(logs_dir / "03_verify.stdout.log", out2)
     write_text(logs_dir / "03_verify.stderr.log", err2)
@@ -206,6 +296,14 @@ def main() -> int:
         write_text(run_dir / "diff.patch", collect_diff(ROOT))
         bundle = make_bundle(run_dir)
         append_trace(["", "## Result", f"- status: fail", f"- bundle: `{bundle.as_posix()}`"])
+        append_history(
+            ts=dt.datetime.now().isoformat(timespec="seconds"),
+            goal=args.goal,
+            run_dir=run_dir,
+            verify_cmd=verify_cmd,
+            result="FAIL",
+            find_doc=find_doc,
+        )
         return 1
 
     append_trace(["", "## Result", "- status: pass"])
@@ -222,6 +320,14 @@ def main() -> int:
             indent=2,
         ),
     )
+    append_history(
+        ts=dt.datetime.now().isoformat(timespec="seconds"),
+        goal=args.goal,
+        run_dir=run_dir,
+        verify_cmd=verify_cmd,
+        result="PASS",
+        find_doc=find_doc,
+    )
     print(f"[adlc_run] run_dir={run_dir.as_posix()}")
     return 0
 
diff --git a/scripts/verify_repo.ps1 b/scripts/verify_repo.ps1
index 40bb1eb..44b74bb 100644
--- a/scripts/verify_repo.ps1
+++ b/scripts/verify_repo.ps1
@@ -7,11 +7,13 @@ $ErrorActionPreference = "Stop"
 $Root = Resolve-Path (Join-Path $PSScriptRoot "..")
 $BuildDirLite = Join-Path $Root "build_lite"
 $RunFull = $Full -or ($env:CTCP_FULL_GATE -eq "1")
+$WriteFixtures = ($env:CTCP_WRITE_FIXTURES -eq "1")
 $ModeName = "LITE"
 if ($RunFull) { $ModeName = "FULL" }
 
 Write-Host "[verify_repo] repo root: $Root"
 Write-Host "[verify_repo] mode: $ModeName"
+Write-Host "[verify_repo] write_fixtures: $WriteFixtures"
 
 function Invoke-ExternalChecked {
   param(
@@ -103,8 +105,14 @@ Invoke-Step -Name "doc index check (sync doc links --check)" -Block {
 }
 
 Invoke-Step -Name "lite scenario replay" -Block {
+  $RunsRoot = Join-Path $Root "simlab\_runs_repo_gate"
+  $SummaryOut = Join-Path $Root "simlab\_runs_repo_gate\_lite_summary.json"
+  if ($WriteFixtures) {
+    $RunsRoot = Join-Path $Root "tests\fixtures\adlc_forge_full_bundle\runs\simlab_lite_runs"
+    $SummaryOut = Join-Path $Root "tests\fixtures\adlc_forge_full_bundle\runs\_simlab_lite_summary.json"
+  }
   Invoke-ExternalChecked -Label "lite scenario replay" -Command {
-    python simlab\run.py --suite lite --runs-root tests\fixtures\adlc_forge_full_bundle\runs\simlab_lite_runs --json-out tests\fixtures\adlc_forge_full_bundle\runs\_simlab_lite_summary.json
+    python simlab\run.py --suite lite --runs-root $RunsRoot --json-out $SummaryOut
   }
 }
 
diff --git a/scripts/verify_repo.sh b/scripts/verify_repo.sh
index 0eaba58..677289b 100644
--- a/scripts/verify_repo.sh
+++ b/scripts/verify_repo.sh
@@ -5,6 +5,7 @@ ROOT="$(cd "$(dirname "${BASH_SOURCE[0]}")/.." && pwd)"
 BUILD_DIR_LITE="${ROOT}/build_lite"
 CTEST_EXE=""
 MODE="${CTCP_FULL_GATE:-0}"
+WRITE_FIXTURES="${CTCP_WRITE_FIXTURES:-0}"
 if [[ "${1:-}" == "--full" ]]; then
   MODE="1"
 fi
@@ -15,6 +16,7 @@ if [[ "${MODE}" == "1" ]]; then
 else
   echo "[verify_repo] mode: LITE"
 fi
+echo "[verify_repo] write_fixtures: ${WRITE_FIXTURES}"
 
 if command -v cmake >/dev/null 2>&1; then
   CMAKE_EXE="$(command -v cmake)"
@@ -47,10 +49,16 @@ echo "[verify_repo] doc index check (sync doc links --check)"
 python3 "${ROOT}/scripts/sync_doc_links.py" --check
 
 echo "[verify_repo] lite scenario replay"
+RUNS_ROOT="${ROOT}/simlab/_runs_repo_gate"
+SUMMARY_OUT="${ROOT}/simlab/_runs_repo_gate/_lite_summary.json"
+if [[ "${WRITE_FIXTURES}" == "1" ]]; then
+  RUNS_ROOT="${ROOT}/tests/fixtures/adlc_forge_full_bundle/runs/simlab_lite_runs"
+  SUMMARY_OUT="${ROOT}/tests/fixtures/adlc_forge_full_bundle/runs/_simlab_lite_summary.json"
+fi
 python3 "${ROOT}/simlab/run.py" \
   --suite lite \
-  --runs-root "${ROOT}/tests/fixtures/adlc_forge_full_bundle/runs/simlab_lite_runs" \
-  --json-out "${ROOT}/tests/fixtures/adlc_forge_full_bundle/runs/_simlab_lite_summary.json"
+  --runs-root "${RUNS_ROOT}" \
+  --json-out "${SUMMARY_OUT}"
 
 if [[ "${MODE}" == "1" ]]; then
   echo "[verify_repo] FULL mode enabled"
diff --git a/simlab/run.py b/simlab/run.py
index 1e53695..7f0b25b 100644
--- a/simlab/run.py
+++ b/simlab/run.py
@@ -81,7 +81,7 @@ def copy_repo(src: Path, dst: Path) -> None:
             if child.startswith("tests/fixtures/adlc_forge_full_bundle/runs/"):
                 ignored.add(name)
                 continue
-            if child.startswith("simlab/_runs/"):
+            if child.startswith("simlab/_runs"):
                 ignored.add(name)
                 continue
         return ignored
