#!/usr/bin/env python3
from __future__ import annotations

import argparse
import re
from pathlib import Path

ROOT = Path(__file__).resolve().parents[1]

BEGIN = "<!-- CTCP:DOC_INDEX:BEGIN -->"
END = "<!-- CTCP:DOC_INDEX:END -->"
LEGACY_BEGIN = "<!-- CTCP:BEGIN_DOC_INDEX -->"
LEGACY_END = "<!-- CTCP:END_DOC_INDEX -->"

CURATED_DOCS = [
    "AGENTS.md",
    "README.md",
    "BUILD.md",
    "PATCH_README.md",
    "TREE.md",
    "docs/00_CORE.md",
    "docs/00_overview.md",
    "docs/01_architecture.md",
    "docs/02_workflow.md",
    "docs/03_quality_gates.md",
    "docs/10_team_mode.md",
    "docs/21_paths_and_locations.md",
    "docs/22_teamnet_adlc.md",
    "docs/22_agent_teamnet.md",
    "docs/30_artifact_contracts.md",
    "docs/12_modules_index.md",
    "docs/13_contracts_index.md",
    "docs/SELF_CHECK_SYSTEM.md",
    "ai_context/00_AI_CONTRACT.md",
]


def render_index() -> str:
    items = [p for p in CURATED_DOCS if (ROOT / p).exists()]
    lines = [
        BEGIN,
        "<!-- (auto-generated by scripts/sync_doc_links.py; curated list) -->",
        "",
        "## Project Docs",
        "",
    ]
    for rel in items:
        lines.append(f"- [{rel}]({rel})")
    lines += ["", END, ""]
    return "\n".join(lines)


def _replace_between_markers(text: str, start: str, end: str, block: str) -> str | None:
    if start in text and end in text:
        pattern = re.escape(start) + r".*?" + re.escape(end)
        return re.sub(pattern, block.strip(), text, flags=re.DOTALL)
    return None


def replace_block(text: str, block: str) -> str:
    updated = _replace_between_markers(text, BEGIN, END, block)
    if updated is not None:
        return updated
    updated = _replace_between_markers(text, LEGACY_BEGIN, LEGACY_END, block)
    if updated is not None:
        return updated
    return text.rstrip() + "\n\n" + block

def main() -> int:
    ap = argparse.ArgumentParser()
    ap.add_argument("--check", action="store_true", help="check only, do not write")
    ap.add_argument("--file", default="README.md", help="target markdown file (default: README.md)")
    args = ap.parse_args()

    target = (ROOT / args.file).resolve()
    if not target.exists():
        print(f"[sync_doc_links][error] target not found: {target}")
        return 1

    block = render_index()
    old = target.read_text(encoding="utf-8", errors="replace")
    new = replace_block(old, block)

    if args.check:
        if new != old:
            print(f"[sync_doc_links][error] out of sync: {target.relative_to(ROOT)}")
            return 1
        print("[sync_doc_links] ok")
        return 0

    if new != old:
        target.write_text(new, encoding="utf-8")
        print(f"[sync_doc_links] updated: {target.relative_to(ROOT)}")
    else:
        print("[sync_doc_links] no changes")
    return 0

if __name__ == "__main__":
    raise SystemExit(main())
